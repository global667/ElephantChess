#ifndef CCHESS_RULES_H
#define CCHESS_RULES_H

#include <vector>
#include <iostream>

#include <QDebug>
#include <QImage>
#include <QTime>
#include <QObject>

//#include "basemodel.h"

//#include <QPoint>

// // A chinese chess board in ascii
//      a b c d e f g h i
//    -------------------
//    9|r h e a g a e h r|9
//    8| | | | | | | | | |8
//    7| |c| | | | | |c| |7
//    6|s| |s| |s| |s| |s|6
//    5| | | | | | | | | |5
//    4| | | | | | | | | |4
//    3|s| |s| |s| |s| |s|3
//    2| |c| | | | | |c| |2
//    1| | | | | | | | | |1
//    0|r h e a g a e h r|0
//    -------------------
//      a b c d e f g h i


static constexpr int ROWS = 10;
static constexpr int COLS = 9;

enum class viewStyleMode { traditional_native, traditional_png, western_png };

enum class pieceType { Empty, General, Advisor, Elephant, Horse, Chariot, Cannon, Soldier };

enum class markerType { Kreuz, Kreis, Dreieck, Linie, Linienende, Viereck };

enum class completePieceType {
	GeneralRot, AdvisorRot, ElephantRot,
	HorseRot, ChariotRot, CannonRot,
	SoldierRot, GeneralSchwarz, AdvisorSchwarz,
	ElephantSchwarz, HorseSchwarz, ChariotSchwarz,
	CannonSchwarz, SoldierSchwarz
};

enum class Color { Red, Black, None};

enum class PieceType {
	General, Advisor, Elephant,
	Horse, Chariot, Cannon,
	Soldier, Empty
};

struct PPiece {
	PieceType piece_type = PieceType::Empty;
    Color color = Color::None;
	//QPoint pos = QPoint(0,0);
	QString name = QString();
	QImage img = QImage();
};

class  Position {

public:
	struct Square {
		PPiece* piece;
	};
	Square board[10][9];
	Color players_color;

	Position() {
		for (int rank = 0; rank < 10; ++rank) {
			for (int file = 0; file < 9; ++file) {
                add_piece(new PPiece{ PieceType::Empty,Color::None, "",QImage() }, rank, file);
				//board[rank][file].piece->piece_type = PieceType::Empty;
			}
		}
		players_color = Color::Red;
	}

	void initBoard();

	void move_piece(int file_from, int rank_from, int file_to, int rank_to);

	// Generates the moves vector of one piece
	std::vector<std::pair<int, int> > generate_piece_moves_for(PieceType piece_type, int file, int rank) const;

	// Generates the real valid moves for one piece (called from Boardview)
	std::vector<std::pair<int, int> > generate_valid_moves_for(PieceType piece_type, int rank, int file);

	// Generates all moves incl. chess, glare and mates
	std::vector<std::pair<QPoint, QPoint> > generate_piece_moves_for_all();

	// Generates the real valid moves, cleaned from all invalid moves like chess etc.
	// (called from the intern engine)
	std::vector<std::pair<QPoint, QPoint> > generate_valid_moves_for_all();

    //toggle color if not None
	void toggleColor(Color* color) {
		if (*color == Color::Red)
			*color = Color::Black;
        if (*color == Color::Black)
			*color = Color::Red;
	}

    bool is_check(Color color, PPiece cboard[10][9]) const;


	// perft driver
	/*
	  rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1
	  depth       nodes    checks    captures
		  1          44         0           2
		  2        1920         6          72
		  3       79666       384        3159
		  4     3290240     19380      115365
		  5   133312995    953251     4917734
		  6  5392831844


	  r1ba1a3/4kn3/2n1b4/pNp1p1p1p/4c4/6P2/P1P2R2P/1CcC5/9/2BAKAB2 w - - 0 1
	  depth       nodes    checks    captures
		  1          38         1           1
		  2        1128        12          10
		  3       43929      1190        2105
		  4     1339047     21299       31409
		  5    53112976   1496697     3262495
	*/

	// count the board checks and captures for every node
	int nodes = 0;
	int checks = 0;
	int captures = 0;

	// perft test
	QString perftTest(int depth);

private:
    void perftDriver(int depth);

	//PPiece captured_piece;
	//PPiece piece;

	void make_move(std::pair<QPoint, QPoint> move, PPiece cboard[10][9]);

	void take_back(std::pair<QPoint, QPoint> move, PPiece cboard[10][9], PPiece captured_piece, PPiece piece) const;

	bool is_evil_glare(Color color) const;

	void generate_general_moves(int file, int rank, std::vector<std::pair<int, int> >& moves) const;

	void generate_advisor_moves(int file, int rank, std::vector<std::pair<int, int> >& moves) const;

	void generate_elephant_moves(int file, int rank, std::vector<std::pair<int, int> >& moves) const;

	void generate_horse_moves(int file, int rank, std::vector<std::pair<int, int> >& moves) const;

	void generate_chariot_moves(int file, int rank, std::vector<std::pair<int, int> >& moves) const;

	void generate_cannon_moves(int file, int rank, std::vector<std::pair<int, int> >& moves) const;

	void generate_soldier_moves(int file, int rank, std::vector<std::pair<int, int> >& moves) const;

	bool is_inside_board(int file, int rank) const {
		return file >= 0 && file < 9 && rank >= 0 && rank < 10;
	}

	void add_piece(PPiece* piece, int file, int rank) {
		if (is_inside_board(file, rank)) {
			board[rank][file].piece = piece;
		}
	}

	// Gibt das Brett in der Konsole aus
	void printBoard();

	void add_move(QPoint from, QPoint to,
		std::vector<std::pair<QPoint, QPoint>>& moves) const {
        if (is_inside_board(to.x(), to.y())) {
			int tmp = to.x();
			to.setX(to.y());
			to.setY(tmp);
			moves.push_back(std::pair(from, to));
		}
	}

	void add_move(int file, int rank,
		std::vector<std::pair<int, int>>& moves) const {
		if (is_inside_board(file, rank)) {
			moves.push_back(std::make_pair(file, rank));
		}
	}
};

#endif // CCHESS_RULES_H
